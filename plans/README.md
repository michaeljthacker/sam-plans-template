# SAM — `plans/` System (Micro-Chunk Workflow)

## What this is
SAM is a **human-directed, AI-executed** workflow for building software through:
- a fixed planning/execution hierarchy,
- explicit artifacts in `plans/`,
- review gates,
- and small, bounded ROLE×TASK "micro-chunks."

All roles are AI-executed except `Human.*` actions, which require human decision-making.
Role names (`Staff`, `Principal`, `PM`, `Product`, `Writer`) are persona labels that shape AI behavior, not team assignments.
The human provides the idea, reviews, confirms, tests manually, and makes decisions. The AI does the work.

This directory (`plans/`) is a reusable template. Copy it into any project repo to adopt SAM.

## Canonical vocabulary (fixed)
Execution hierarchy:

> BUILD → MILESTONE → PHASE → STEP → (commits happen)

Commits are a side-effect of implementation, not a structural level. They happen during Phase execution (≥1 per Phase) but are not a planning unit.

Reserved language:
- **TASK** refers exclusively to the action component of a ROLE×TASK pair (e.g., `Staff.DraftQuestions`). It is never used in the execution hierarchy.

## Action ID convention
Action IDs use two dot-separated segments:

> `Role.Task`

Collapsed role names:

| Full label | Role ID |
|------------|---------|
| Engineer (Staff-level) | `Staff` |
| Engineer (Principal-level) | `Principal` |
| Project Manager | `PM` |
| Product Manager | `Product` |
| Tech Writer | `Writer` |
| Human | `Human` |

Examples: `Staff.DraftQuestions`, `Principal.CodeReview`, `PM.StatusUpdate`, `Human.ResolveBlocker`

Template filenames mirror action IDs with underscores: `Staff_DraftQuestions.txt`

## System-level vs instance-level files
### System-level (reusable; defines how SAM works)
- `plans/README.md` (this file)
- `plans/copilot-instructions.md` (AI bootstrap — deploy to `.github/copilot-instructions.md` in your project)
- `plans/templates/registry.json`
- `plans/templates/*.txt`

### Instance-level (project-specific; generated by actions or filled in)
- `plans/BUILD.md` — generated by `Product.ProductVision`
- `plans/MILESTONE.md` — generated by `Principal.MilestonePlan`
- `plans/STATUS.md` — updated every action
- `plans/BACKLOG.md`
- `plans/CHANGELOG.md`
- `plans/DECISIONS.md` — project-level architectural choices
- `plans/STANDARDS.md` — team-level technical standards (seed from defaults)
- `plans/thread.md` — active working memory (AI-readable, not machine-parseable)
- `plans/state.json` — **routing source of truth**

## Routing and state

### Source of truth
- `plans/state.json` is authoritative for: **what action happens next**
- `plans/STATUS.md` is authoritative for: **human-readable snapshot** (must be updated every action)

### Pause model
Every action completes, updates state, and **stops**. Prompts never chain automatically.
The human reviews, then triggers the next action (new chat, or a runner that executes one action then stops).

`state.json` includes `pause_type`:
- `"continue"` — AI completed an action; human can review then proceed. Next action is an AI role.
- `"decision"` — A human decision is required. `next_action_id` will be `Human.*`.

### Error handling
- **Unexpected failures** → set `next_action_id = "Human.ResolveBlocker"`, add a blocker entry describing the failure. Human determines next steps.
- **Expected failures** (e.g., failing tests during implementation) → handled within the action itself. Staff fixes them or escalates questions to Principal.

## Micro-chunk execution model
Each action is small and bounded. A typical workflow is a sequence of micro-chunks.

### Manual execution loop
1. Open `plans/state.json`
2. Read `next_action_id`
3. In `plans/templates/registry.json`, find that action and its `template_path`
4. Provide the AI the listed `inputs`
5. AI must:
   - do exactly the task (bounded)
   - update all `required_outputs`
   - update `plans/STATUS.md` (mandatory every action)
   - update `plans/state.json` with `last_action`, `next_action_id`, and `pause_type`
6. Stop. The workflow pauses until the human triggers the next action.

### Runner concept (optional)
A dumb runner can automate steps 1–5:
- Read `plans/state.json`
- Lookup the action in `registry.json`
- Load template + inputs
- Execute action
- Verify gates (e.g., STATUS updated)
- Stop after one action (human-controlled pacing)

## Expected lifecycle

### 1. Idea & framing
- Human provides project idea
- `Product.ProductVision` → generates root `README.md` + `plans/BUILD.md`
- `Principal.BuildReview` → reviews feasibility and constraints
- Human approves

### 2. Milestone planning
- `Principal.MilestonePlan` → drafts `plans/MILESTONE.md` for the current milestone
- `Human.ApproveMilestone` → human reviews and approves scope

### 3. Phase execution (repeat per Phase)
Each Phase follows this sequence:

| # | Action | Purpose |
|---|--------|---------|
| 1 | `Staff.DraftQuestions` | Draft questions needed before implementing |
| 2 | `Principal.AnswerQuestions` | Answer questions so Staff can proceed |
| 3 | `Staff.ImplementationExecution` | Implement the Phase (≥1 commit) |
| 4 | `Principal.CodeReview` | Review implementation |
| 5 | `Staff.ReviewReconciliation` | Address required feedback (loop to 4 if needed) |
| 6 | `PM.StatusUpdate` | Update STATUS/BACKLOG/CHANGELOG |
| 7 | `Writer.DocumentationUpdate` | Update docs (optional/skippable) |
| 8 | `Human.PhaseApproval` | Human confirms; commit |
| 9 | `PM.AdvancePhase` | Increment phase_id; set up next cycle |

### 4. Milestone closeout
- `PM.MilestoneCloseout` → update BACKLOG/CHANGELOG, trigger ThreadMaintenance
- Proceed to next milestone (`Principal.MilestonePlan`) or end build

## Thread management (keep it small)
`plans/thread.md` is **active working memory**, not a transcript. It is AI-readable, not machine-parseable.
The runner may check "was thread.md modified?" but does not parse its content.

When a Phase completes or the thread gets long/noisy, run `PM.ThreadMaintenance`:
- Promote durable decisions → `plans/DECISIONS.md` and/or `plans/STANDARDS.md`
- Promote important implementation details → `plans/MILESTONE.md`
- Compress resolved Q/A → 1–3 bullets, delete the back-and-forth
- (Optional) append raw content to `plans/thread.archive.md`

## Execution model assumptions
- **Single-threaded.** One Phase is active at a time. `state.json` tracks a single active `build_id`, `milestone_id`, and `phase_id`.
- If a bug in a previous milestone is found, handle it as an unplanned Step in the current Phase, document in `thread.md` and `CHANGELOG.md`, and resume.
- **Branching** is a project decision, not SAM-prescribed. Record your branching convention in `STANDARDS.md` or your project README.

## ID conventions (recommended)
- Builds: `B1`, `B2`, …
- Milestones: `M1`, `M2`, …
- Phases: `P1`, `P2`, …
- Steps: `S1`, `S2`, …

Common references:
- Phase: `B1-M2-P4`
- Step: `B1-M2-P4-S2`

## Quickstart — bootstrapping a new project
1. Copy the `plans/` directory into your project repo
2. Copy `plans/copilot-instructions.md` to `.github/copilot-instructions.md` in your project root
   - This is the file VS Code Copilot reads automatically — it tells the AI how to run SAM
   - The copy in `plans/` is the template source; `.github/` is where it takes effect
3. Write a one-sentence project idea (or a few paragraphs)
4. Run `Product.ProductVision` → generates root README + `plans/BUILD.md`
5. Run `Principal.BuildReview` → validates feasibility
6. Human approves → run `Principal.MilestonePlan` → generates `plans/MILESTONE.md`
7. `Human.ApproveMilestone` → approve scope
8. Phase execution begins with `Staff.DraftQuestions` for P1

From step 4 onward, each step is: open a new chat, say "run the next step", and the AI
reads `state.json` to know what to do. Review its output, then repeat.

## Where to look next
- `plans/templates/registry.json` — machine-verifiable action list + gates
- `plans/templates/*.txt` — individual action prompts
- `example/` — a filled-in example (optional reference)
